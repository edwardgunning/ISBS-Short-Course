---
title: "Part 1: Data Representation and Smoothing"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center')
```

<center>

![](../logo/isbs-logo.png) ![](../logo/whitespace.png) ![](../logo/fda-logo.png)

</center>

<style>
.colored {
  background-color: #DDDDDD;
}
</style>

# Load Packages

```{r, warning = FALSE, message = FALSE}
library(fda) # load the fda package
```

---

---

# The `fd` class

The `fda` package represents functional observations (i.e., *curves*) using a **basis function expansion**. That is, each functional observation $x_i(t), \ i = 1, \dots, N$ is represented as a linear combination (or weighted sum) of known basis functions $\{\phi_k(t)\}_{k=1}^k$ as:

$$x_i (t)=\sum_{k=1}^{K} c_{ik} \phi_k(t).$$

This means that our representation of a functional dataset $x_1(t), \dots, x_N(t)$ should comprise two component parts:

1. The set of known **basis functions** $\{ \phi_K(t) \}_{k=1}^K$. These are *common to all curves*. They are defined in the `fda` package as a `basisfd` class.

2. The basis coefficients $c_{ik}$. We need $K$ basis coefficients (i.e., 1 coefficient per basis function) to define each individual functional observation. Therefore, for the full dataset of $N$ observations we have an $K \times N$ matrix of basis coefficients.

<details><summary><b>Construct a cubic B-spline basis with 20 basis functions</b></summary>
```{r create-bspline, fig.asp=0.8, fig.width=5}
bspl_20 <- create.bspline.basis(rangeval = c(0, 100), # range of t values
                                nbasis = 20, # number of basis functions
                                norder = 4) # order of the piecewise polynomial (4 = cubic)

# show it is a `basisfd` object
class(bspl_20)
# or 
is.basis(bspl_20)

# plot our basis
plot(bspl_20)
```
</details>

<details><summary><b>Construct a Fourier basis with 20 basis functions</b></summary>
```{r create-fourier, fig.asp=0.8, fig.width=5}
fourier_20 <- create.fourier.basis(rangeval = c(0, 100), # range of t values
                                nbasis = 20) # number of basis functions

# plot our basis
plot(fourier_20)
```
</details>

---

In the `fda` package, we combine these two component parts to produce a `fd` ("functional data") object. If we know the basis function system and the matrix of basis coefficients, the code to set up the `fd` object is very simple. We will walk through a short example.

Let's first set up a basis of $20$ cubic B-spline basis functions on $[0,100]$.

```{r}
bspl_20 <- create.bspline.basis(rangeval = c(0, 100), nbasis = 20, norder = 4)
```

Now, let's imagine we have $N=10$ functional observations. We require a $20\times10$ matrix of basis coefficients. In practice we would calculate or know these. However, for the purposes of this demonstration we will just simulate them randomly on our computer.

```{r}
set.seed(1996) # so random draws are the same
C <- matrix(rnorm(20*10), nrow = 20, ncol = 10) # 20x10 matrix of random values
```

Now that we have our basis object and our matrix of basis coefficients, we can set up our `fd` object using the `fd` function.

```{r}
toy_fd <- fd(coef = C, basisobj = bspl_20)
```

Now that we have done this, let's go ahead an inspect our first `fd` object.

```{r, fig.asp=0.8, fig.width=6}
class(toy_fd) # (or can do is.fd(toy_fd))
plot(toy_fd, xlab = "t", ylab = "x(t)")
title("Our first fd object")
```

**Note**: For more information on building `fd` objects, see Ramsay, Hooker and Graves (2009, pp. 29-31).


# Producing smooth functions from noisy observations

In most cases we don't know the basis coefficients, we have to estimate or calculate them from noisy sampled measurements.

# Summarising `fd` objects

Mean -- show mean of coefficients.

Covariance -- just calculation

Boxplot -- add more.



# References

* Ramsay, J. O., Hooker, G., & Graves, S. (2009). Functional Data Analysis with R and MATLAB. Springer-Verlag. https://doi.org/10.1007/978-0-387-98185-7

